use chrono::{Datelike, NaiveDate};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

/// The relation to be proved.
#[derive(PartialEq, Debug, Copy, Clone)]
pub enum Relation {
    Younger,
    Older,
}

/// Public part of the proof. The fields included in the QR code.
#[derive(Debug, Clone)]
pub struct PublicQr {
    /// Today julian date.
    pub today: i32,

    /// Relation.
    pub relation: Relation,

    /// Minimal (maximal) difference between 'today' and 'birthday' in days.
    pub delta: i32,

    /// Contract address on the blockchain. Big-endian encoded number in Field
    /// range.
    pub contract: Vec<u8>,
}

impl PublicQr {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        PublicQr {
            today: 0,
            relation: Relation::Younger,
            delta: 0,
            contract: Vec::new(),
        }
    }

    pub fn to_json(&self) -> String {
        format!(
            r#""today": {}, "delta": {}, "relation":{}, "contract": 0x{}"#,
            self.today,
            self.delta,
            self.relation.clone() as u8,
            hex::encode(&self.contract)
        )
    }
}

/// Public part of the proof. The fields stored on-chain.
#[derive(Debug, Clone)]
pub struct PublicChain {
    /// Digest of the photo. Big-endian encoded number in Field
    /// range.
    pub photo_hash: Vec<u8>,

    /// Prover key computed by a one-way function from the private part of the proof.
    pub prover_key: Vec<u8>,
}

impl PublicChain {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        PublicChain {
            photo_hash: Vec::new(),
            prover_key: Vec::new(),
        }
    }
}

/// Private part of the proof
#[derive(Debug, Clone)]
pub struct Private {
    /// Birthday - julian daprote. Private part of the proof.
    pub birthday: i32,

    /// Private nonce known only to the prover and to the
    /// certifier. Prevents brute-force attacks using the limited number
    /// of birthdays.  Big-endian encoded number in Field range.
    pub nonce: Vec<u8>,
}

impl Private {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Private {
            birthday: 0,
            nonce: Vec::new(),
        }
    }
}

static COMMON_ERA_JD: i32 = 1721425;

pub fn naive_date_to_jd(nd: NaiveDate) -> i32 {
    nd.num_days_from_ce() + COMMON_ERA_JD
}

pub fn age_to_delta(birthday: i32, age: i32, relation: Relation) -> i32 {
    let dbirth = NaiveDate::from_num_days_from_ce(birthday - COMMON_ERA_JD);
    let dtest =
        NaiveDate::from_ymd_opt(dbirth.year() + age, dbirth.month(), dbirth.day()).unwrap_or(
            NaiveDate::from_ymd(dbirth.year() + age, dbirth.month(), dbirth.day() - 1),
        );
    let delta = dtest.signed_duration_since(dbirth).num_days() as i32;
    if relation == Relation::Older {
        delta + 1
    } else {
        delta - 1
    }
}

/// Request for QR code generation from phone app.
#[derive(Debug)]
pub struct QrRequest {
    pub qr: PublicQr,
    pub chain: PublicChain,
    pub private: Private,
}

impl QrRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        QrRequest {
            qr: PublicQr::new(),
            chain: PublicChain::new(),
            private: Private::new(),
        }
    }

    pub fn to_qr_code_string() -> String {
        String::from("")
    }

    pub fn from_qr_code_string(_qr_str: &str) -> Self {
        QrRequest::new()
    }

    pub fn is_relation_valid(&self) -> bool {
        match self.qr.relation {
            Relation::Younger => self.private.birthday + self.qr.delta > self.qr.today,
            Relation::Older => self.private.birthday + self.qr.delta < self.qr.today,
        }
    }
}

/// QR code containing the proof. Is generated by the prover and
/// verified by the verifier
#[derive(Debug, Clone)]
pub struct ProofQrCode {
    /// Public parameters
    pub public: PublicQr,
    /// elliptic curve points packed
    pub proof: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct QrError {}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QrJson {
    pub today: i32,
    pub relation: u8,
    pub delta: i32,
    pub contract: String,
    pub proof: String,
}

impl ToString for ProofQrCode {
    fn to_string(&self) -> String {
        let js = QrJson {
            today: self.public.today,
            relation: if self.public.relation == Relation::Younger {
                1
            } else {
                0
            },
            delta: self.public.delta,
            contract: String::from("0x") + &hex::encode(self.public.contract.clone()),
            proof: bs58::encode(&self.proof).into_string(),
        };
        serde_json::to_string(&js).unwrap()
    }
}

impl FromStr for ProofQrCode {
    type Err = QrError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let p: QrJson = serde_json::from_str(s).map_err(|_| QrError {})?;
	let mut contract = p.contract;
	if contract.starts_with("0x") {
	    contract = String::from(&contract[2..]);
	}
        Ok(ProofQrCode {
            public: PublicQr {
                today: p.today,
                relation: if p.relation == 0 {
                    Relation::Older
                } else {
                    Relation::Younger
                },
                delta: p.delta,
                contract: hex::decode(contract).map_err(|_| QrError {})?,
            },
            proof: bs58::decode(&p.proof).into_vec().map_err(|_| QrError {})?,
        })
    }
}
