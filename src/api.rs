use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use std::io::{Cursor, Read, Write};

use std::str::FromStr;
use regex::{Captures,Regex};
use chrono::{Datelike, NaiveDate};

/// The relation to be proved.
#[derive(PartialEq, Debug, Copy, Clone)]
pub enum Relation {
    Younger,
    Older,
}

/// Public part of the proof. The fields included in the QR code.
#[derive(Debug, Clone)]
pub struct PublicQr {
    /// Today julian date.
    pub today: i32,

    /// Relation.
    pub relation: Relation,

    /// Minimal (maximal) difference between 'today' and 'birthday' in days.
    pub delta: i32,

    /// Contract address on the blockchain. Big-endian encoded number in Field
    /// range.
    pub contract: Vec<u8>,
}

impl PublicQr {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        PublicQr {
            today: 0,
            relation: Relation::Younger,
            delta: 0,
            contract: Vec::new(),
        }
    }

    pub fn to_json(&self) -> String {
        format!(
            r#""today": {}, "delta": {}, "relation":{}, "contract": 0x{}"#,
            self.today,
            self.delta,
            self.relation.clone() as u8,
	    hex::encode(&self.contract)
		
        )
    }

}

/// Public part of the proof. The fields stored on-chain.
#[derive(Debug, Clone)]
pub struct PublicChain {
    /// Digest of the photo. Big-endian encoded number in Field
    /// range.
    pub photo_hash: Vec<u8>,

    /// Prover key computed by a one-way function from the private part of the proof.
    pub prover_key: Vec<u8>,
}

impl PublicChain {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        PublicChain {
            photo_hash: Vec::new(),
            prover_key: Vec::new(),
        }
    }
}

/// Private part of the proof
#[derive(Debug, Clone)]
pub struct Private {
    /// Birthday - julian daprote. Private part of the proof.
    pub birthday: i32,

    /// Private nonce known only to the prover and to the
    /// certifier. Prevents brute-force attacks using the limited number
    /// of birthdays.  Big-endian encoded number in Field range.
    pub nonce: Vec<u8>,
}

impl Private {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Private {
            birthday: 0,
            nonce: Vec::new(),
        }
    }
}

static COMMON_ERA_JD: i32 = 1721425;

pub fn naive_date_to_jd(nd: NaiveDate) -> i32 {
    nd.num_days_from_ce() + COMMON_ERA_JD
}

pub fn age_to_delta(birthday: i32, age: i32, relation: Relation) -> i32 {
    let dbirth = NaiveDate::from_num_days_from_ce(birthday - COMMON_ERA_JD);
    let dtest =
        NaiveDate::from_ymd_opt(dbirth.year() + age, dbirth.month(), dbirth.day()).unwrap_or(
            NaiveDate::from_ymd(dbirth.year() + age, dbirth.month(), dbirth.day() - 1),
        );
    let delta = dtest.signed_duration_since(dbirth).num_days() as i32;
    if relation == Relation::Older {
        delta + 1
    } else {
        delta - 1
    }
}

/// Request for QR code generation from phone app.
#[derive(Debug)]
pub struct QrRequest {
    pub qr: PublicQr,
    pub chain: PublicChain,
    pub private: Private,
}

impl QrRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        QrRequest {
            qr: PublicQr::new(),
            chain: PublicChain::new(),
            private: Private::new(),
        }
    }

    pub fn to_qr_code_string() -> String {
        String::from("")
    }

    pub fn from_qr_code_string(_qr_str: &str) -> Self {
        QrRequest::new()
    }

    pub fn is_relation_valid(&self) -> bool {
        match self.qr.relation {
            Relation::Younger => self.private.birthday + self.qr.delta > self.qr.today,
            Relation::Older => self.private.birthday + self.qr.delta < self.qr.today,
        }
    }
}

/// QR code containing the proof. Is generated by the prover and
/// verified by the verifier
#[derive(Debug, Clone)]
pub struct ProofQrCode {
    /// Public part of the proof.
    pub public: PublicQr,

    // Proof a,b,c curve points.
    pub proof: String,

    pub proof_bytes: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct QrError {}

impl ProofQrCode {
    pub fn public_to_string(&self) -> String {
        let mut wtr = vec![];
        wtr.write_i32::<BigEndian>(self.public.today).unwrap();
        wtr.write_i32::<BigEndian>(self.public.delta).unwrap();
        wtr.push(self.public.relation.clone() as u8);
        wtr.write_all(&self.public.contract.clone()).unwrap();
        bs58::encode(wtr).into_string()
    }

    pub fn public_from_str(s: &str) -> Result<PublicQr, QrError> {
        let mut rdr = Cursor::new(bs58::decode(s).into_vec().map_err(|_| QrError {})?);

        let today = rdr.read_i32::<BigEndian>().map_err(|_| QrError {})?;
        let delta = rdr.read_i32::<BigEndian>().map_err(|_| QrError {})?;
        const YOUNGER: u8 = Relation::Younger as u8;
        let relation = match rdr.read_u8().map_err(|_| QrError {})? {
            YOUNGER => Relation::Younger,
            _ => Relation::Older,
        };
        let mut contract: Vec<u8> = Vec::new();
        rdr.read_to_end(&mut contract).unwrap();

        Ok(PublicQr {
            today,
            delta,
            relation,
            contract,
        })
    }


}

impl ToString for ProofQrCode {
    fn to_string(&self) -> String {
	let unescaped = format!(r#"{{ {}, "proof": {{ {} }} }}"#, self.public.to_json(), self.proof.clone());
	let re = Regex::new("(0x[01234567890abcdef]+)").unwrap();
	re.replace_all(&unescaped, |caps: &Captures| {
	    format!("\"{}\"", &caps[1])
	}).to_string()
    }
}

impl FromStr for ProofQrCode {
    type Err = QrError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split(';').collect();
        if parts.len() != 2 {
            Err(QrError {})
        } else {
            Ok(ProofQrCode {
                public: Self::public_from_str(parts[0])?,
                proof_bytes: Vec::new(), // TODO
                proof: String::from(parts[1]),
            })
        }
    }
}
